Input : gcc -m32 Prob4.c
In file included from Prob4.c:1: 
/usr/include/stdio.h:28:10: fatal error: bits/libc-header-start.h: No such file or directory 
28  | #include <bits/libc-header-start.h> 
    |           ^~~~~~~~~~~~~~~~~~~~~~~~~~ 
compilation terminated.

///
file for 32bit compilation is missing, therefor installing header files
sudo apt-get update
sudo apt-get install gcc-multilib g++-multilib
///

now compiling : gcc -m32 Prob4.c
executing : ./a.out
In bar
In bar
In bar... (output)

/// understanding the code.
#include <stdio.h>
int *p; //global integer pointer
int val; //global variable

void foo(int a){ //argument passed as a copy.
  p = &a; //pointer pointing to a which is created in scope of foo
  val = *(--p); // decrement the pointer (no longer pointing to a), then assign val to that p's content
  printf("In foo\n"); // prints string.
}


void bar(int b){//creates a copy of b
  p = &b; //pointer points to address of b
  *(--p) = val; //decrements p, and put put val into that location. 
  printf("In bar\n"); // prints in bar.
}

int main(){
  int a = 1, b = 2;
  foo(a); //calling foo with a == 1
  bar(b); //calling bar with b == 2
  return 0;
}

/// Understanding call stack.
whenever a function is called, stack frame(aka activation record) is push onto the call stack and when it is finished, stack frame is poped out.
Stack pointer points to top of the call stack, naturally to the recent added function.

using gdb to understand memory locations
///

input : gcc -m32 -g Prob4.c -o Prob4
input : gdb Prob4
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git...
// making breakpoint for main, foo, bar
Reading symbols from Prob4...
(gdb) b main
Breakpoint 1 at 0x124a: file Prob4.c, line 19.
(gdb) b foo
Breakpoint 2 at 0x119e: file Prob4.c, line 6.
(gdb) b bar
Breakpoint 3 at 0x11ef: file Prob4.c, line 13.

//for each function call we will do following things:
// step - step into function
// n - moves the program by single step
// p &variable - prints the address of variable
// x &variable - shows memory content at specific address
// watch variable - it stop whenever value of expression changes

run 
p &a 
p &b 
step
p &a
next

Breakpoint 1, main () at Prob4.c:19
19        int a = 1, b = 2;
(gdb) b foo
Breakpoint 2 at 0x5655619e: file Prob4.c, line 6.
(gdb) b bar
Breakpoint 3 at 0x565561ef: file Prob4.c, line 13.
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) n
Program not restarted.
(gdb) step
20        foo(a);
(gdb) step

Breakpoint 2, foo (a=1) at Prob4.c:6
6         p = &a;
(gdb) watch p
Hardware watchpoint 4: p
(gdb) watch val
Hardware watchpoint 5: val
(gdb) watch bar
Cannot watch constant value `bar'.
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0x0
New value = (int *) 0xffffc190
foo (a=1) at Prob4.c:7
7         val = *(--p);
(gdb) next

Hardware watchpoint 4: p

Old value = (int *) 0xffffc190
New value = (int *) 0xffffc18c
foo (a=1) at Prob4.c:7
7         val = *(--p);
(gdb) x val
0x0:    Cannot access memory at address 0x0
(gdb) x &val
0x56559010 <val>:       0x00000000
(gdb) next

Hardware watchpoint 5: val

Old value = 0
New value = 1448436323
foo (a=1) at Prob4.c:8
8         printf("In foo\n");
(gdb) x &a
0xffffc190:     0x00000001
(gdb) x p
0xffffc18c:     0x56556263
(gdb) x &val
0x56559010 <val>:       0x56556263
(gdb) next
In foo
9       }
(gdb) next
main () at Prob4.c:21
21        bar(b);
(gdb) p bar
$1 = {void (int)} 0x565561de <bar>
(gdb) x bar
0x565561de <bar>:       0x53e58955
(gdb) next

Breakpoint 3, bar (b=2) at Prob4.c:13
13        p = &b;
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0xffffc18c
New value = (int *) 0xffffc190
bar (b=2) at Prob4.c:14
14        *(--p) = val;
(gdb) x &b
0xffffc190:     0x00000002
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0xffffc190
New value = (int *) 0xffffc18c
bar (b=2) at Prob4.c:14
14        *(--p) = val;
(gdb) x &val
0x56559010 <val>:       0x56556263
(gdb) next
15        printf("In bar\n");
(gdb) p 0xffffc18c
$2 = 4294951308
(gdb) x 0xffffc18c
0xffffc18c:     0x56556263
(gdb) x 0x56556263
0x56556263 <main+52>:   0x8310c483
(gdb) disassemble main
Dump of assembler code for function main:
   0x5655622f <+0>:     lea    0x4(%esp),%ecx
   0x56556233 <+4>:     and    $0xfffffff0,%esp
   0x56556236 <+7>:     push   -0x4(%ecx)
   0x56556239 <+10>:    push   %ebp
   0x5655623a <+11>:    mov    %esp,%ebp
   0x5655623c <+13>:    push   %ecx
   0x5655623d <+14>:    sub    $0x14,%esp
   0x56556240 <+17>:    call   0x56556281 <__x86.get_pc_thunk.ax>
   0x56556245 <+22>:    add    $0x2d93,%eax
   0x5655624a <+27>:    movl   $0x1,-0x10(%ebp)
   0x56556251 <+34>:    movl   $0x2,-0xc(%ebp)
   0x56556258 <+41>:    sub    $0xc,%esp
   0x5655625b <+44>:    push   -0x10(%ebp)
   0x5655625e <+47>:    call   0x5655618d <foo>
   0x56556263 <+52>:    add    $0x10,%esp
   0x56556266 <+55>:    sub    $0xc,%esp
   0x56556269 <+58>:    push   -0xc(%ebp)
   0x5655626c <+61>:    call   0x565561de <bar>
   0x56556271 <+66>:    add    $0x10,%esp
   0x56556274 <+69>:    mov    $0x0,%eax
   0x56556279 <+74>:    mov    -0x4(%ebp),%ecx
   0x5655627c <+77>:    leave
   0x5655627d <+78>:    lea    -0x4(%ecx),%esp
   0x56556280 <+81>:    ret
End of assembler dump.
(gdb) next
In bar
16      }
(gdb) next
main () at Prob4.c:21
21        bar(b);
(gdb) q

the program keeps on looping at function bar, because of overwritting of instructions due to which just after completion of bar function 0x56556263 address is called (which is bar's stack frame's return address) which is eventully after foo function in main function. 
(gdb) frame 0
#0  bar (b=2) at Prob4.c:15
15        printf("In bar\n");
(gdb) info frame
Stack level 0, frame at 0xffffc190:
 eip = 0x56556215 in bar (Prob4.c:15); saved eip = 0x56556263
 called by frame at 0xffffc1d0
 source language c.
 Arglist at 0xffffc188, args: b=2
 Locals at 0xffffc188, Previous frame's sp is 0xffffc190
 Saved registers:
  ebx at 0xffffc184, ebp at 0xffffc188, eip at 0xffffc18c
(gdb) 

eip -  memory address of next instruction.

to give the same effect in 64 bit machine.