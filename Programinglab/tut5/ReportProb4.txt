Input : gcc -m32 Prob4.c
In file included from Prob4.c:1: 
/usr/include/stdio.h:28:10: fatal error: bits/libc-header-start.h: No such file or directory 
28  | #include <bits/libc-header-start.h> 
    |           ^~~~~~~~~~~~~~~~~~~~~~~~~~ 
compilation terminated.

///
file for 32bit compilation is missing, therefor installing header files
sudo apt-get update
sudo apt-get install gcc-multilib g++-multilib
///

now compiling : gcc -m32 Prob4.c
executing : ./a.out
In bar
In bar
In bar... (output)

/// understanding the code.
#include <stdio.h>
int *p; //global integer pointer
int val; //global variable

void foo(int a){ //argument passed as a copy.
  p = &a; //pointer pointing to a which is created in scope of foo
  val = *(--p); // decrement the pointer (no longer pointing to a), then assign val to that p's content
  printf("In foo\n"); // prints string.
}


void bar(int b){//creates a copy of b
  p = &b; //pointer points to address of b
  *(--p) = val; //decrements p, and put put val into that location. 
  printf("In bar\n"); // prints in bar.
}

int main(){
  int a = 1, b = 2;
  foo(a); //calling foo with a = 1
  bar(b); //calling bar with b = 2
  return 0;
}

/// Understanding of call stack.
whenever a function is called, stack frame(aka activation record) is push onto the call stack and when it is finished, stack frame is poped out.
Stack pointer points to top of the call stack, naturally to the recent added function.

using gdb to understand memory locations
///

input : gcc -m32 -g Prob4.c -o Prob4
input : gdb Prob4
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git...
// making breakpoint for main, foo, bar
//for each function call we will do following things:
// step - step into function
// n - moves the program by single step
// p &variable - prints the address of variable
// x &variable - shows memory content at specific address
// watch variable - it stop whenever value of expression changes

Breakpoint 1, main () at Prob4.c:19
19        int a = 1, b = 2;
(gdb) b foo
Breakpoint 2 at 0x5655619e: file Prob4.c, line 6.
(gdb) b bar
Breakpoint 3 at 0x565561ef: file Prob4.c, line 13.
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
(gdb) step
20        foo(a);
(gdb) step

Breakpoint 2, foo (a=1) at Prob4.c:6
6         p = &a;
(gdb) watch p
Hardware watchpoint 4: p
(gdb) watch val
Hardware watchpoint 5: val
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0x0
New value = (int *) 0xffffc190
foo (a=1) at Prob4.c:7
7         val = *(--p);
(gdb) next

Hardware watchpoint 4: p

Old value = (int *) 0xffffc190
New value = (int *) 0xffffc18c
foo (a=1) at Prob4.c:7
7         val = *(--p);
(gdb) x val
0x0:    Cannot access memory at address 0x0
(gdb) x &val
0x56559010 <val>:       0x00000000
(gdb) next

Hardware watchpoint 5: val

Old value = 0
New value = 1448436323
foo (a=1) at Prob4.c:8
8         printf("In foo\n");
(gdb) x &a
0xffffc190:     0x00000001
(gdb) x p
0xffffc18c:     0x56556263 //value at the location where p is pointing.
(gdb) x &val
0x56559010 <val>:       0x56556263 
(gdb) next
In foo
9       }
(gdb) next
main () at Prob4.c:21
21        bar(b);
(gdb) p bar
$1 = {void (int)} 0x565561de <bar>
(gdb) x bar
0x565561de <bar>:       0x53e58955
(gdb) next

Breakpoint 3, bar (b=2) at Prob4.c:13
13        p = &b;
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0xffffc18c
New value = (int *) 0xffffc190
bar (b=2) at Prob4.c:14
14        *(--p) = val;
(gdb) x &b
0xffffc190:     0x00000002
(gdb) step

Hardware watchpoint 4: p

Old value = (int *) 0xffffc190
New value = (int *) 0xffffc18c
bar (b=2) at Prob4.c:14
14        *(--p) = val;
(gdb) x &val
0x56559010 <val>:       0x56556263
(gdb) next
15        printf("In bar\n");
(gdb) p 0xffffc18c
$2 = 4294951308
(gdb) x 0xffffc18c
0xffffc18c:     0x56556263
(gdb) x 0x56556263
0x56556263 <main+52>:   0x8310c483
(gdb) disassemble main
Dump of assembler code for function main:
   0x5655622f <+0>:     lea    0x4(%esp),%ecx
   0x56556233 <+4>:     and    $0xfffffff0,%esp
   0x56556236 <+7>:     push   -0x4(%ecx)
   0x56556239 <+10>:    push   %ebp
   0x5655623a <+11>:    mov    %esp,%ebp
   0x5655623c <+13>:    push   %ecx
   0x5655623d <+14>:    sub    $0x14,%esp
   0x56556240 <+17>:    call   0x56556281 <__x86.get_pc_thunk.ax>
   0x56556245 <+22>:    add    $0x2d93,%eax
   0x5655624a <+27>:    movl   $0x1,-0x10(%ebp)
   0x56556251 <+34>:    movl   $0x2,-0xc(%ebp)
   0x56556258 <+41>:    sub    $0xc,%esp
   0x5655625b <+44>:    push   -0x10(%ebp)
   0x5655625e <+47>:    call   0x5655618d <foo>
   0x56556263 <+52>:    add    $0x10,%esp // this is the address which is inside val.
   0x56556266 <+55>:    sub    $0xc,%esp
   0x56556269 <+58>:    push   -0xc(%ebp)
   0x5655626c <+61>:    call   0x565561de <bar>
   0x56556271 <+66>:    add    $0x10,%esp
   0x56556274 <+69>:    mov    $0x0,%eax
   0x56556279 <+74>:    mov    -0x4(%ebp),%ecx
   0x5655627c <+77>:    leave
   0x5655627d <+78>:    lea    -0x4(%ecx),%esp
   0x56556280 <+81>:    ret
End of assembler dump.
(gdb) next
In bar
16      }
(gdb) next
main () at Prob4.c:21
21        bar(b);
(gdb) q

the program keeps on looping at function bar, because of overwritting of instructions due to which just after completion of bar function 0x56556263 address is called (which is bar's stack frame's return address) which is eventully after foo function in main function. 

/// checking the stack frame for information
(gdb) frame 0
#0  bar (b=2) at Prob4.c:15
15        printf("In bar\n");
(gdb) info frame
Stack level 0, frame at 0xffffc190:
 eip = 0x56556215 in bar (Prob4.c:15); saved eip = 0x56556263
 called by frame at 0xffffc1d0
 source language c.
 Arglist at 0xffffc188, args: b=2
 Locals at 0xffffc188, Previous frame's sp is 0xffffc190
 Saved registers:
  ebx at 0xffffc184, ebp at 0xffffc188, eip at 0xffffc18c
(gdb) 

eip -  memory address of next instruction. which is exactly where p is pointing.
*(--p) = val; // this line puts the address from main function in eip register and therefore program keeps looping.

/// For 64 bit the program is compiled and executed.
input : gcc -m64 Prob4.c -o Prob4_x64
input : ./Prob4_x64
In foo
In bar

if somehow we can make rip of bar = rip of foo. we can achive the loop

registers used 
rip : Register Instruction Pointer, which act as next instruction pointer in x86_64
currently holding the address rip = 0x555555555207

/// checking stack frame for foo
21        foo(a);
(gdb) info frame
Stack level 0, frame at 0x7fffffffce90:
 rip = 0x555555555163 in foo (Prob4.c:7); saved rip = 0x555555555219
 called by frame at 0x7fffffffceb0
 source language c.
 Arglist at 0x7fffffffce80, args: a=1
 Locals at 0x7fffffffce80, Previous frame's sp is 0x7fffffffce90
 Saved registers:
 rbp at 0x7fffffffce80, rip at 0x7fffffffce88

the address of rip is 0x7fffffffce88 and that of a is 0x7fffffffce80, which is precisely 8 bytes away.
so initiallizing p to address of a, and then doing +3 will get it to 0x7fffffffce88 store this in val.

then activation record will call bar.

Stack level 0, frame at 0x7fffffffce90:
 rip = 0x5555555551b0 in bar (Prob4.c:15); 
    saved rip = 0x555555555223
 called by frame at 0x7fffffffceb0
 source language c.
 Arglist at 0x7fffffffce80, args: b=2
 Locals at 0x7fffffffce80, Previous frame's sp is 0x7fffffffce90
 Saved registers:
  rbp at 0x7fffffffce80, rip at 0x7fffffffce88

this have similar structure. so we can use exact logic of moving pointer to +3 and then restoring the next instrictions address to return of foo.


#include <stdio.h>
int *p;
int val;

void foo(int a){
  p = &a;
  p += 3;
  val = *(p);
  printf("In foo\n");
}

void bar(int b){
  p = &b;
  p += 4;
  *(--p) = val;
  printf("In bar\n");
}

int main(){
  int a = 1, b = 2;
  foo(a);
  bar(b);
  return 0;
}

----------------------------------------------------------------